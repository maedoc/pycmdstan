// Code generated by Stan version 2.17.0

// [[Rcpp::depends(rstan)]]
#include <stan/model/standalone_functions_header.hpp>

namespace allcall_functions { 
using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using namespace stan::math;

// [[Rcpp::export]]
boost::ecuyer1988 __create_rng(int seed) {
  return(boost::ecuyer1988(seed));
}

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "unkown file name");
    reader.add_event(425, 425, "end", "unkown file name");
    return reader;
}

// [[Rcpp::export]]
template <bool propto>
double
call_bernoulli_lpmf(const int& y,
                        const int& theta, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 3;
        return stan::math::promote_scalar<fun_return_scalar_t__>(bernoulli_log(y,theta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
double
call_bernoulli_lpmf(const int& y,
                        const int& theta, std::ostream* pstream__) {
    return call_bernoulli_lpmf<false>(y,theta, pstream__);
}


struct call_bernoulli_lpmf_functor__ {
    template <bool propto>
        double
    operator()(const int& y,
                        const int& theta, std::ostream* pstream__) const {
        return call_bernoulli_lpmf(y, theta, pstream__);
    }
};

// [[Rcpp::export]]
double
call_bernoulli_cdf(const int& y,
                       const int& theta, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 6;
        return stan::math::promote_scalar<fun_return_scalar_t__>(bernoulli_cdf(y,theta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_bernoulli_cdf_functor__ {
            double
    operator()(const int& y,
                       const int& theta, std::ostream* pstream__) const {
        return call_bernoulli_cdf(y, theta, pstream__);
    }
};

// [[Rcpp::export]]
double
call_bernoulli_lcdf(const int& y,
                        const int& theta, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 9;
        return stan::math::promote_scalar<fun_return_scalar_t__>(bernoulli_cdf_log(y,theta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_bernoulli_lcdf_functor__ {
            double
    operator()(const int& y,
                        const int& theta, std::ostream* pstream__) const {
        return call_bernoulli_lcdf(y, theta, pstream__);
    }
};

// [[Rcpp::export]]
double
call_bernoulli_lccdf(const int& y,
                         const int& theta, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 12;
        return stan::math::promote_scalar<fun_return_scalar_t__>(bernoulli_ccdf_log(y,theta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_bernoulli_lccdf_functor__ {
            double
    operator()(const int& y,
                         const int& theta, std::ostream* pstream__) const {
        return call_bernoulli_lccdf(y, theta, pstream__);
    }
};

// [[Rcpp::export]]
template <class RNG>
int
call_bernoulli_rng(const int& theta, RNG& base_rng__, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 15;
        return stan::math::promote_scalar<fun_return_scalar_t__>(bernoulli_rng(theta, base_rng__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_bernoulli_rng_functor__ {
    template <class RNG>
        int
    operator()(const int& theta, RNG& base_rng__, std::ostream* pstream__) const {
        return call_bernoulli_rng(theta, base_rng__, pstream__);
    }
};

// [[Rcpp::export]]
template <class RNG>
int
call_bernoulli_logit_rng(const int& alpha, RNG& base_rng__, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 18;
        return stan::math::promote_scalar<fun_return_scalar_t__>(bernoulli_logit_rng(alpha, base_rng__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_bernoulli_logit_rng_functor__ {
    template <class RNG>
        int
    operator()(const int& alpha, RNG& base_rng__, std::ostream* pstream__) const {
        return call_bernoulli_logit_rng(alpha, base_rng__, pstream__);
    }
};

// [[Rcpp::export]]
template <bool propto>
double
call_binomial_lpmf(const int& y,
                       const int& N,
                       const int& theta, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 21;
        return stan::math::promote_scalar<fun_return_scalar_t__>(binomial_log(y,N,theta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
double
call_binomial_lpmf(const int& y,
                       const int& N,
                       const int& theta, std::ostream* pstream__) {
    return call_binomial_lpmf<false>(y,N,theta, pstream__);
}


struct call_binomial_lpmf_functor__ {
    template <bool propto>
        double
    operator()(const int& y,
                       const int& N,
                       const int& theta, std::ostream* pstream__) const {
        return call_binomial_lpmf(y, N, theta, pstream__);
    }
};

// [[Rcpp::export]]
double
call_binomial_cdf(const int& y,
                      const int& N,
                      const int& theta, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 24;
        return stan::math::promote_scalar<fun_return_scalar_t__>(binomial_cdf(y,N,theta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_binomial_cdf_functor__ {
            double
    operator()(const int& y,
                      const int& N,
                      const int& theta, std::ostream* pstream__) const {
        return call_binomial_cdf(y, N, theta, pstream__);
    }
};

// [[Rcpp::export]]
double
call_binomial_lcdf(const int& y,
                       const int& N,
                       const int& theta, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 27;
        return stan::math::promote_scalar<fun_return_scalar_t__>(binomial_cdf_log(y,N,theta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_binomial_lcdf_functor__ {
            double
    operator()(const int& y,
                       const int& N,
                       const int& theta, std::ostream* pstream__) const {
        return call_binomial_lcdf(y, N, theta, pstream__);
    }
};

// [[Rcpp::export]]
double
call_binomial_lccdf(const int& y,
                        const int& N,
                        const int& theta, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 30;
        return stan::math::promote_scalar<fun_return_scalar_t__>(binomial_ccdf_log(y,N,theta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_binomial_lccdf_functor__ {
            double
    operator()(const int& y,
                        const int& N,
                        const int& theta, std::ostream* pstream__) const {
        return call_binomial_lccdf(y, N, theta, pstream__);
    }
};

// [[Rcpp::export]]
template <class RNG>
int
call_binomial_rng(const int& N,
                      const int& theta, RNG& base_rng__, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 33;
        return stan::math::promote_scalar<fun_return_scalar_t__>(binomial_rng(N,theta, base_rng__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_binomial_rng_functor__ {
    template <class RNG>
        int
    operator()(const int& N,
                      const int& theta, RNG& base_rng__, std::ostream* pstream__) const {
        return call_binomial_rng(N, theta, base_rng__, pstream__);
    }
};

// [[Rcpp::export]]
template <bool propto>
double
call_neg_binomial_lpmf(const int& y,
                           const int& alpha,
                           const int& beta, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 36;
        return stan::math::promote_scalar<fun_return_scalar_t__>(neg_binomial_log(y,alpha,beta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
double
call_neg_binomial_lpmf(const int& y,
                           const int& alpha,
                           const int& beta, std::ostream* pstream__) {
    return call_neg_binomial_lpmf<false>(y,alpha,beta, pstream__);
}


struct call_neg_binomial_lpmf_functor__ {
    template <bool propto>
        double
    operator()(const int& y,
                           const int& alpha,
                           const int& beta, std::ostream* pstream__) const {
        return call_neg_binomial_lpmf(y, alpha, beta, pstream__);
    }
};

// [[Rcpp::export]]
double
call_neg_binomial_cdf(const int& y,
                          const int& alpha,
                          const int& beta, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 39;
        return stan::math::promote_scalar<fun_return_scalar_t__>(neg_binomial_cdf(y,alpha,beta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_neg_binomial_cdf_functor__ {
            double
    operator()(const int& y,
                          const int& alpha,
                          const int& beta, std::ostream* pstream__) const {
        return call_neg_binomial_cdf(y, alpha, beta, pstream__);
    }
};

// [[Rcpp::export]]
double
call_neg_binomial_lcdf(const int& y,
                           const int& alpha,
                           const int& beta, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 42;
        return stan::math::promote_scalar<fun_return_scalar_t__>(neg_binomial_cdf_log(y,alpha,beta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_neg_binomial_lcdf_functor__ {
            double
    operator()(const int& y,
                           const int& alpha,
                           const int& beta, std::ostream* pstream__) const {
        return call_neg_binomial_lcdf(y, alpha, beta, pstream__);
    }
};

// [[Rcpp::export]]
double
call_neg_binomial_lccdf(const int& y,
                            const int& alpha,
                            const int& beta, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 45;
        return stan::math::promote_scalar<fun_return_scalar_t__>(neg_binomial_ccdf_log(y,alpha,beta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_neg_binomial_lccdf_functor__ {
            double
    operator()(const int& y,
                            const int& alpha,
                            const int& beta, std::ostream* pstream__) const {
        return call_neg_binomial_lccdf(y, alpha, beta, pstream__);
    }
};

// [[Rcpp::export]]
template <class RNG>
int
call_neg_binomial_rng(const int& alpha,
                          const int& beta, RNG& base_rng__, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 48;
        return stan::math::promote_scalar<fun_return_scalar_t__>(neg_binomial_rng(alpha,beta, base_rng__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_neg_binomial_rng_functor__ {
    template <class RNG>
        int
    operator()(const int& alpha,
                          const int& beta, RNG& base_rng__, std::ostream* pstream__) const {
        return call_neg_binomial_rng(alpha, beta, base_rng__, pstream__);
    }
};

// [[Rcpp::export]]
template <bool propto>
double
call_neg_binomial_2_lpmf(const int& y,
                             const int& mu,
                             const int& phi, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 51;
        return stan::math::promote_scalar<fun_return_scalar_t__>(neg_binomial_2_log(y,mu,phi));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
double
call_neg_binomial_2_lpmf(const int& y,
                             const int& mu,
                             const int& phi, std::ostream* pstream__) {
    return call_neg_binomial_2_lpmf<false>(y,mu,phi, pstream__);
}


struct call_neg_binomial_2_lpmf_functor__ {
    template <bool propto>
        double
    operator()(const int& y,
                             const int& mu,
                             const int& phi, std::ostream* pstream__) const {
        return call_neg_binomial_2_lpmf(y, mu, phi, pstream__);
    }
};

// [[Rcpp::export]]
double
call_neg_binomial_2_cdf(const int& y,
                            const int& mu,
                            const int& phi, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 54;
        return stan::math::promote_scalar<fun_return_scalar_t__>(neg_binomial_2_cdf(y,mu,phi));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_neg_binomial_2_cdf_functor__ {
            double
    operator()(const int& y,
                            const int& mu,
                            const int& phi, std::ostream* pstream__) const {
        return call_neg_binomial_2_cdf(y, mu, phi, pstream__);
    }
};

// [[Rcpp::export]]
double
call_neg_binomial_2_lcdf(const int& y,
                             const int& mu,
                             const int& phi, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 57;
        return stan::math::promote_scalar<fun_return_scalar_t__>(neg_binomial_2_cdf_log(y,mu,phi));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_neg_binomial_2_lcdf_functor__ {
            double
    operator()(const int& y,
                             const int& mu,
                             const int& phi, std::ostream* pstream__) const {
        return call_neg_binomial_2_lcdf(y, mu, phi, pstream__);
    }
};

// [[Rcpp::export]]
double
call_neg_binomial_2_lccdf(const int& y,
                              const int& mu,
                              const int& phi, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 60;
        return stan::math::promote_scalar<fun_return_scalar_t__>(neg_binomial_2_ccdf_log(y,mu,phi));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_neg_binomial_2_lccdf_functor__ {
            double
    operator()(const int& y,
                              const int& mu,
                              const int& phi, std::ostream* pstream__) const {
        return call_neg_binomial_2_lccdf(y, mu, phi, pstream__);
    }
};

// [[Rcpp::export]]
template <class RNG>
int
call_neg_binomial_2_rng(const int& mu,
                            const int& phi, RNG& base_rng__, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 63;
        return stan::math::promote_scalar<fun_return_scalar_t__>(neg_binomial_2_rng(mu,phi, base_rng__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_neg_binomial_2_rng_functor__ {
    template <class RNG>
        int
    operator()(const int& mu,
                            const int& phi, RNG& base_rng__, std::ostream* pstream__) const {
        return call_neg_binomial_2_rng(mu, phi, base_rng__, pstream__);
    }
};

// [[Rcpp::export]]
template <class RNG>
int
call_neg_binomial_2_log_rng(const int& eta,
                                const int& phi, RNG& base_rng__, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 66;
        return stan::math::promote_scalar<fun_return_scalar_t__>(neg_binomial_2_log_rng(eta,phi, base_rng__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_neg_binomial_2_log_rng_functor__ {
    template <class RNG>
        int
    operator()(const int& eta,
                                const int& phi, RNG& base_rng__, std::ostream* pstream__) const {
        return call_neg_binomial_2_log_rng(eta, phi, base_rng__, pstream__);
    }
};

// [[Rcpp::export]]
template <bool propto>
double
call_poisson_lpmf(const int& y,
                      const int& lambda, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 69;
        return stan::math::promote_scalar<fun_return_scalar_t__>(poisson_log(y,lambda));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
double
call_poisson_lpmf(const int& y,
                      const int& lambda, std::ostream* pstream__) {
    return call_poisson_lpmf<false>(y,lambda, pstream__);
}


struct call_poisson_lpmf_functor__ {
    template <bool propto>
        double
    operator()(const int& y,
                      const int& lambda, std::ostream* pstream__) const {
        return call_poisson_lpmf(y, lambda, pstream__);
    }
};

// [[Rcpp::export]]
double
call_poisson_cdf(const int& y,
                     const int& lambda, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 72;
        return stan::math::promote_scalar<fun_return_scalar_t__>(poisson_cdf(y,lambda));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_poisson_cdf_functor__ {
            double
    operator()(const int& y,
                     const int& lambda, std::ostream* pstream__) const {
        return call_poisson_cdf(y, lambda, pstream__);
    }
};

// [[Rcpp::export]]
double
call_poisson_lcdf(const int& y,
                      const int& lambda, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 75;
        return stan::math::promote_scalar<fun_return_scalar_t__>(poisson_cdf_log(y,lambda));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_poisson_lcdf_functor__ {
            double
    operator()(const int& y,
                      const int& lambda, std::ostream* pstream__) const {
        return call_poisson_lcdf(y, lambda, pstream__);
    }
};

// [[Rcpp::export]]
double
call_poisson_lccdf(const int& y,
                       const int& lambda, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 78;
        return stan::math::promote_scalar<fun_return_scalar_t__>(poisson_ccdf_log(y,lambda));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_poisson_lccdf_functor__ {
            double
    operator()(const int& y,
                       const int& lambda, std::ostream* pstream__) const {
        return call_poisson_lccdf(y, lambda, pstream__);
    }
};

// [[Rcpp::export]]
template <class RNG>
int
call_poisson_rng(const int& lambda, RNG& base_rng__, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 81;
        return stan::math::promote_scalar<fun_return_scalar_t__>(poisson_rng(lambda, base_rng__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_poisson_rng_functor__ {
    template <class RNG>
        int
    operator()(const int& lambda, RNG& base_rng__, std::ostream* pstream__) const {
        return call_poisson_rng(lambda, base_rng__, pstream__);
    }
};

// [[Rcpp::export]]
template <class RNG>
int
call_poisson_log_rng(const int& alpha, RNG& base_rng__, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 84;
        return stan::math::promote_scalar<fun_return_scalar_t__>(poisson_log_rng(alpha, base_rng__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_poisson_log_rng_functor__ {
    template <class RNG>
        int
    operator()(const int& alpha, RNG& base_rng__, std::ostream* pstream__) const {
        return call_poisson_log_rng(alpha, base_rng__, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_normal_lpdf(const T0__& y,
                     const T1__& mu,
                     const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 87;
        return stan::math::promote_scalar<fun_return_scalar_t__>(normal_log(y,mu,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_normal_lpdf(const T0__& y,
                     const T1__& mu,
                     const T2__& sigma, std::ostream* pstream__) {
    return call_normal_lpdf<false>(y,mu,sigma, pstream__);
}


struct call_normal_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                     const T1__& mu,
                     const T2__& sigma, std::ostream* pstream__) const {
        return call_normal_lpdf(y, mu, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_normal_cdf(const T0__& y,
                    const T1__& mu,
                    const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 90;
        return stan::math::promote_scalar<fun_return_scalar_t__>(normal_cdf(y,mu,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_normal_cdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                    const T1__& mu,
                    const T2__& sigma, std::ostream* pstream__) const {
        return call_normal_cdf(y, mu, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_normal_lcdf(const T0__& y,
                     const T1__& mu,
                     const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 93;
        return stan::math::promote_scalar<fun_return_scalar_t__>(normal_cdf_log(y,mu,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_normal_lcdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                     const T1__& mu,
                     const T2__& sigma, std::ostream* pstream__) const {
        return call_normal_lcdf(y, mu, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_normal_lccdf(const T0__& y,
                      const T1__& mu,
                      const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 96;
        return stan::math::promote_scalar<fun_return_scalar_t__>(normal_ccdf_log(y,mu,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_normal_lccdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                      const T1__& mu,
                      const T2__& sigma, std::ostream* pstream__) const {
        return call_normal_lccdf(y, mu, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, class RNG>
typename boost::math::tools::promote_args<T0__, T1__>::type
call_normal_rng(const T0__& mu,
                    const T1__& sigma, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 99;
        return stan::math::promote_scalar<fun_return_scalar_t__>(normal_rng(mu,sigma, base_rng__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_normal_rng_functor__ {
    template <typename T0__, typename T1__, class RNG>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& mu,
                    const T1__& sigma, RNG& base_rng__, std::ostream* pstream__) const {
        return call_normal_rng(mu, sigma, base_rng__, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
call_exp_mod_normal_lpdf(const T0__& y,
                             const T1__& mu,
                             const T2__& sigma,
                             const T3__& lambda, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 102;
        return stan::math::promote_scalar<fun_return_scalar_t__>(exp_mod_normal_log(y,mu,sigma,lambda));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
call_exp_mod_normal_lpdf(const T0__& y,
                             const T1__& mu,
                             const T2__& sigma,
                             const T3__& lambda, std::ostream* pstream__) {
    return call_exp_mod_normal_lpdf<false>(y,mu,sigma,lambda, pstream__);
}


struct call_exp_mod_normal_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
    operator()(const T0__& y,
                             const T1__& mu,
                             const T2__& sigma,
                             const T3__& lambda, std::ostream* pstream__) const {
        return call_exp_mod_normal_lpdf(y, mu, sigma, lambda, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
call_exp_mod_normal_cdf(const T0__& y,
                            const T1__& mu,
                            const T2__& sigma,
                            const T3__& lambda, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 105;
        return stan::math::promote_scalar<fun_return_scalar_t__>(exp_mod_normal_cdf(y,mu,sigma,lambda));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_exp_mod_normal_cdf_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
    operator()(const T0__& y,
                            const T1__& mu,
                            const T2__& sigma,
                            const T3__& lambda, std::ostream* pstream__) const {
        return call_exp_mod_normal_cdf(y, mu, sigma, lambda, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
call_exp_mod_normal_lcdf(const T0__& y,
                             const T1__& mu,
                             const T2__& sigma,
                             const T3__& lambda, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 108;
        return stan::math::promote_scalar<fun_return_scalar_t__>(exp_mod_normal_cdf_log(y,mu,sigma,lambda));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_exp_mod_normal_lcdf_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
    operator()(const T0__& y,
                             const T1__& mu,
                             const T2__& sigma,
                             const T3__& lambda, std::ostream* pstream__) const {
        return call_exp_mod_normal_lcdf(y, mu, sigma, lambda, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
call_exp_mod_normal_lccdf(const T0__& y,
                              const T1__& mu,
                              const T2__& sigma,
                              const T3__& lambda, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 111;
        return stan::math::promote_scalar<fun_return_scalar_t__>(exp_mod_normal_ccdf_log(y,mu,sigma,lambda));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_exp_mod_normal_lccdf_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
    operator()(const T0__& y,
                              const T1__& mu,
                              const T2__& sigma,
                              const T3__& lambda, std::ostream* pstream__) const {
        return call_exp_mod_normal_lccdf(y, mu, sigma, lambda, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, class RNG>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_exp_mod_normal_rng(const T0__& mu,
                            const T1__& sigma,
                            const T2__& lambda, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 114;
        return stan::math::promote_scalar<fun_return_scalar_t__>(exp_mod_normal_rng(mu,sigma,lambda, base_rng__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_exp_mod_normal_rng_functor__ {
    template <typename T0__, typename T1__, typename T2__, class RNG>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& mu,
                            const T1__& sigma,
                            const T2__& lambda, RNG& base_rng__, std::ostream* pstream__) const {
        return call_exp_mod_normal_rng(mu, sigma, lambda, base_rng__, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
call_skew_normal_lpdf(const T0__& y,
                          const T1__& xi,
                          const T2__& omega,
                          const T3__& alpha, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 117;
        return stan::math::promote_scalar<fun_return_scalar_t__>(skew_normal_log(y,xi,omega,alpha));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
call_skew_normal_lpdf(const T0__& y,
                          const T1__& xi,
                          const T2__& omega,
                          const T3__& alpha, std::ostream* pstream__) {
    return call_skew_normal_lpdf<false>(y,xi,omega,alpha, pstream__);
}


struct call_skew_normal_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
    operator()(const T0__& y,
                          const T1__& xi,
                          const T2__& omega,
                          const T3__& alpha, std::ostream* pstream__) const {
        return call_skew_normal_lpdf(y, xi, omega, alpha, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
call_skew_normal_cdf(const T0__& y,
                         const T1__& xi,
                         const T2__& omega,
                         const T3__& alpha, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 120;
        return stan::math::promote_scalar<fun_return_scalar_t__>(skew_normal_cdf(y,xi,omega,alpha));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_skew_normal_cdf_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
    operator()(const T0__& y,
                         const T1__& xi,
                         const T2__& omega,
                         const T3__& alpha, std::ostream* pstream__) const {
        return call_skew_normal_cdf(y, xi, omega, alpha, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
call_skew_normal_lcdf(const T0__& y,
                          const T1__& xi,
                          const T2__& omega,
                          const T3__& alpha, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 123;
        return stan::math::promote_scalar<fun_return_scalar_t__>(skew_normal_cdf_log(y,xi,omega,alpha));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_skew_normal_lcdf_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
    operator()(const T0__& y,
                          const T1__& xi,
                          const T2__& omega,
                          const T3__& alpha, std::ostream* pstream__) const {
        return call_skew_normal_lcdf(y, xi, omega, alpha, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
call_skew_normal_lccdf(const T0__& y,
                           const T1__& xi,
                           const T2__& omega,
                           const T3__& alpha, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 126;
        return stan::math::promote_scalar<fun_return_scalar_t__>(skew_normal_ccdf_log(y,xi,omega,alpha));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_skew_normal_lccdf_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
    operator()(const T0__& y,
                           const T1__& xi,
                           const T2__& omega,
                           const T3__& alpha, std::ostream* pstream__) const {
        return call_skew_normal_lccdf(y, xi, omega, alpha, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, class RNG>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_skew_normal_rng(const T0__& xi,
                         const T1__& omega,
                         const T2__& alpha, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 129;
        return stan::math::promote_scalar<fun_return_scalar_t__>(skew_normal_rng(xi,omega,alpha, base_rng__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_skew_normal_rng_functor__ {
    template <typename T0__, typename T1__, typename T2__, class RNG>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& xi,
                         const T1__& omega,
                         const T2__& alpha, RNG& base_rng__, std::ostream* pstream__) const {
        return call_skew_normal_rng(xi, omega, alpha, base_rng__, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
call_student_t_lpdf(const T0__& y,
                        const T1__& nu,
                        const T2__& mu,
                        const T3__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 132;
        return stan::math::promote_scalar<fun_return_scalar_t__>(student_t_log(y,nu,mu,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
call_student_t_lpdf(const T0__& y,
                        const T1__& nu,
                        const T2__& mu,
                        const T3__& sigma, std::ostream* pstream__) {
    return call_student_t_lpdf<false>(y,nu,mu,sigma, pstream__);
}


struct call_student_t_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
    operator()(const T0__& y,
                        const T1__& nu,
                        const T2__& mu,
                        const T3__& sigma, std::ostream* pstream__) const {
        return call_student_t_lpdf(y, nu, mu, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
call_student_t_cdf(const T0__& y,
                       const T1__& nu,
                       const T2__& mu,
                       const T3__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 135;
        return stan::math::promote_scalar<fun_return_scalar_t__>(student_t_cdf(y,nu,mu,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_student_t_cdf_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
    operator()(const T0__& y,
                       const T1__& nu,
                       const T2__& mu,
                       const T3__& sigma, std::ostream* pstream__) const {
        return call_student_t_cdf(y, nu, mu, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
call_student_t_lcdf(const T0__& y,
                        const T1__& nu,
                        const T2__& mu,
                        const T3__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 138;
        return stan::math::promote_scalar<fun_return_scalar_t__>(student_t_cdf_log(y,nu,mu,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_student_t_lcdf_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
    operator()(const T0__& y,
                        const T1__& nu,
                        const T2__& mu,
                        const T3__& sigma, std::ostream* pstream__) const {
        return call_student_t_lcdf(y, nu, mu, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
call_student_t_lccdf(const T0__& y,
                         const T1__& nu,
                         const T2__& mu,
                         const T3__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 141;
        return stan::math::promote_scalar<fun_return_scalar_t__>(student_t_ccdf_log(y,nu,mu,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_student_t_lccdf_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
    operator()(const T0__& y,
                         const T1__& nu,
                         const T2__& mu,
                         const T3__& sigma, std::ostream* pstream__) const {
        return call_student_t_lccdf(y, nu, mu, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, class RNG>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_student_t_rng(const T0__& nu,
                       const T1__& mu,
                       const T2__& sigma, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 144;
        return stan::math::promote_scalar<fun_return_scalar_t__>(student_t_rng(nu,mu,sigma, base_rng__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_student_t_rng_functor__ {
    template <typename T0__, typename T1__, typename T2__, class RNG>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& nu,
                       const T1__& mu,
                       const T2__& sigma, RNG& base_rng__, std::ostream* pstream__) const {
        return call_student_t_rng(nu, mu, sigma, base_rng__, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_cauchy_lpdf(const T0__& y,
                     const T1__& mu,
                     const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 147;
        return stan::math::promote_scalar<fun_return_scalar_t__>(cauchy_log(y,mu,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_cauchy_lpdf(const T0__& y,
                     const T1__& mu,
                     const T2__& sigma, std::ostream* pstream__) {
    return call_cauchy_lpdf<false>(y,mu,sigma, pstream__);
}


struct call_cauchy_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                     const T1__& mu,
                     const T2__& sigma, std::ostream* pstream__) const {
        return call_cauchy_lpdf(y, mu, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_cauchy_cdf(const T0__& y,
                    const T1__& mu,
                    const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 150;
        return stan::math::promote_scalar<fun_return_scalar_t__>(cauchy_cdf(y,mu,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_cauchy_cdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                    const T1__& mu,
                    const T2__& sigma, std::ostream* pstream__) const {
        return call_cauchy_cdf(y, mu, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_cauchy_lcdf(const T0__& y,
                     const T1__& mu,
                     const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 153;
        return stan::math::promote_scalar<fun_return_scalar_t__>(cauchy_cdf_log(y,mu,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_cauchy_lcdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                     const T1__& mu,
                     const T2__& sigma, std::ostream* pstream__) const {
        return call_cauchy_lcdf(y, mu, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_cauchy_lccdf(const T0__& y,
                      const T1__& mu,
                      const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 156;
        return stan::math::promote_scalar<fun_return_scalar_t__>(cauchy_ccdf_log(y,mu,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_cauchy_lccdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                      const T1__& mu,
                      const T2__& sigma, std::ostream* pstream__) const {
        return call_cauchy_lccdf(y, mu, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, class RNG>
typename boost::math::tools::promote_args<T0__, T1__>::type
call_cauchy_rng(const T0__& mu,
                    const T1__& sigma, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 159;
        return stan::math::promote_scalar<fun_return_scalar_t__>(cauchy_rng(mu,sigma, base_rng__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_cauchy_rng_functor__ {
    template <typename T0__, typename T1__, class RNG>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& mu,
                    const T1__& sigma, RNG& base_rng__, std::ostream* pstream__) const {
        return call_cauchy_rng(mu, sigma, base_rng__, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_double_exponential_lpdf(const T0__& y,
                                 const T1__& mu,
                                 const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 162;
        return stan::math::promote_scalar<fun_return_scalar_t__>(double_exponential_log(y,mu,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_double_exponential_lpdf(const T0__& y,
                                 const T1__& mu,
                                 const T2__& sigma, std::ostream* pstream__) {
    return call_double_exponential_lpdf<false>(y,mu,sigma, pstream__);
}


struct call_double_exponential_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                                 const T1__& mu,
                                 const T2__& sigma, std::ostream* pstream__) const {
        return call_double_exponential_lpdf(y, mu, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_double_exponential_cdf(const T0__& y,
                                const T1__& mu,
                                const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 165;
        return stan::math::promote_scalar<fun_return_scalar_t__>(double_exponential_cdf(y,mu,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_double_exponential_cdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                                const T1__& mu,
                                const T2__& sigma, std::ostream* pstream__) const {
        return call_double_exponential_cdf(y, mu, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_double_exponential_lcdf(const T0__& y,
                                 const T1__& mu,
                                 const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 168;
        return stan::math::promote_scalar<fun_return_scalar_t__>(double_exponential_cdf_log(y,mu,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_double_exponential_lcdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                                 const T1__& mu,
                                 const T2__& sigma, std::ostream* pstream__) const {
        return call_double_exponential_lcdf(y, mu, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_double_exponential_lccdf(const T0__& y,
                                  const T1__& mu,
                                  const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 171;
        return stan::math::promote_scalar<fun_return_scalar_t__>(double_exponential_ccdf_log(y,mu,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_double_exponential_lccdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                                  const T1__& mu,
                                  const T2__& sigma, std::ostream* pstream__) const {
        return call_double_exponential_lccdf(y, mu, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, class RNG>
typename boost::math::tools::promote_args<T0__, T1__>::type
call_double_exponential_rng(const T0__& mu,
                                const T1__& sigma, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 174;
        return stan::math::promote_scalar<fun_return_scalar_t__>(double_exponential_rng(mu,sigma, base_rng__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_double_exponential_rng_functor__ {
    template <typename T0__, typename T1__, class RNG>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& mu,
                                const T1__& sigma, RNG& base_rng__, std::ostream* pstream__) const {
        return call_double_exponential_rng(mu, sigma, base_rng__, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_logistic_lpdf(const T0__& y,
                       const T1__& mu,
                       const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 177;
        return stan::math::promote_scalar<fun_return_scalar_t__>(logistic_log(y,mu,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_logistic_lpdf(const T0__& y,
                       const T1__& mu,
                       const T2__& sigma, std::ostream* pstream__) {
    return call_logistic_lpdf<false>(y,mu,sigma, pstream__);
}


struct call_logistic_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                       const T1__& mu,
                       const T2__& sigma, std::ostream* pstream__) const {
        return call_logistic_lpdf(y, mu, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_logistic_cdf(const T0__& y,
                      const T1__& mu,
                      const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 180;
        return stan::math::promote_scalar<fun_return_scalar_t__>(logistic_cdf(y,mu,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_logistic_cdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                      const T1__& mu,
                      const T2__& sigma, std::ostream* pstream__) const {
        return call_logistic_cdf(y, mu, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_logistic_lcdf(const T0__& y,
                       const T1__& mu,
                       const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 183;
        return stan::math::promote_scalar<fun_return_scalar_t__>(logistic_cdf_log(y,mu,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_logistic_lcdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                       const T1__& mu,
                       const T2__& sigma, std::ostream* pstream__) const {
        return call_logistic_lcdf(y, mu, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_logistic_lccdf(const T0__& y,
                        const T1__& mu,
                        const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 186;
        return stan::math::promote_scalar<fun_return_scalar_t__>(logistic_ccdf_log(y,mu,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_logistic_lccdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                        const T1__& mu,
                        const T2__& sigma, std::ostream* pstream__) const {
        return call_logistic_lccdf(y, mu, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, class RNG>
typename boost::math::tools::promote_args<T0__, T1__>::type
call_logistic_rng(const T0__& mu,
                      const T1__& sigma, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 189;
        return stan::math::promote_scalar<fun_return_scalar_t__>(logistic_rng(mu,sigma, base_rng__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_logistic_rng_functor__ {
    template <typename T0__, typename T1__, class RNG>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& mu,
                      const T1__& sigma, RNG& base_rng__, std::ostream* pstream__) const {
        return call_logistic_rng(mu, sigma, base_rng__, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_gumbel_lpdf(const T0__& y,
                     const T1__& mu,
                     const T2__& beta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 192;
        return stan::math::promote_scalar<fun_return_scalar_t__>(gumbel_log(y,mu,beta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_gumbel_lpdf(const T0__& y,
                     const T1__& mu,
                     const T2__& beta, std::ostream* pstream__) {
    return call_gumbel_lpdf<false>(y,mu,beta, pstream__);
}


struct call_gumbel_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                     const T1__& mu,
                     const T2__& beta, std::ostream* pstream__) const {
        return call_gumbel_lpdf(y, mu, beta, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_gumbel_cdf(const T0__& y,
                    const T1__& mu,
                    const T2__& beta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 195;
        return stan::math::promote_scalar<fun_return_scalar_t__>(gumbel_cdf(y,mu,beta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_gumbel_cdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                    const T1__& mu,
                    const T2__& beta, std::ostream* pstream__) const {
        return call_gumbel_cdf(y, mu, beta, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_gumbel_lcdf(const T0__& y,
                     const T1__& mu,
                     const T2__& beta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 198;
        return stan::math::promote_scalar<fun_return_scalar_t__>(gumbel_cdf_log(y,mu,beta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_gumbel_lcdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                     const T1__& mu,
                     const T2__& beta, std::ostream* pstream__) const {
        return call_gumbel_lcdf(y, mu, beta, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_gumbel_lccdf(const T0__& y,
                      const T1__& mu,
                      const T2__& beta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 201;
        return stan::math::promote_scalar<fun_return_scalar_t__>(gumbel_ccdf_log(y,mu,beta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_gumbel_lccdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                      const T1__& mu,
                      const T2__& beta, std::ostream* pstream__) const {
        return call_gumbel_lccdf(y, mu, beta, pstream__);
    }
};

template <typename T0__, typename T1__, class RNG>
typename boost::math::tools::promote_args<T0__, T1__>::type
call_gumbel_rng(const T0__& mu,
                    const T1__& beta, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 204;
        return stan::math::promote_scalar<fun_return_scalar_t__>(gumbel_rng(mu,beta, base_rng__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_gumbel_rng_functor__ {
    template <typename T0__, typename T1__, class RNG>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& mu,
                    const T1__& beta, RNG& base_rng__, std::ostream* pstream__) const {
        return call_gumbel_rng(mu, beta, base_rng__, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_lognormal_lpdf(const T0__& y,
                        const T1__& mu,
                        const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 207;
        return stan::math::promote_scalar<fun_return_scalar_t__>(lognormal_log(y,mu,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_lognormal_lpdf(const T0__& y,
                        const T1__& mu,
                        const T2__& sigma, std::ostream* pstream__) {
    return call_lognormal_lpdf<false>(y,mu,sigma, pstream__);
}


struct call_lognormal_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                        const T1__& mu,
                        const T2__& sigma, std::ostream* pstream__) const {
        return call_lognormal_lpdf(y, mu, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_lognormal_cdf(const T0__& y,
                       const T1__& mu,
                       const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 210;
        return stan::math::promote_scalar<fun_return_scalar_t__>(lognormal_cdf(y,mu,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_lognormal_cdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                       const T1__& mu,
                       const T2__& sigma, std::ostream* pstream__) const {
        return call_lognormal_cdf(y, mu, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_lognormal_lcdf(const T0__& y,
                        const T1__& mu,
                        const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 213;
        return stan::math::promote_scalar<fun_return_scalar_t__>(lognormal_cdf_log(y,mu,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_lognormal_lcdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                        const T1__& mu,
                        const T2__& sigma, std::ostream* pstream__) const {
        return call_lognormal_lcdf(y, mu, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_lognormal_lccdf(const T0__& y,
                         const T1__& mu,
                         const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 216;
        return stan::math::promote_scalar<fun_return_scalar_t__>(lognormal_ccdf_log(y,mu,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_lognormal_lccdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                         const T1__& mu,
                         const T2__& sigma, std::ostream* pstream__) const {
        return call_lognormal_lccdf(y, mu, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, class RNG>
typename boost::math::tools::promote_args<T0__, T1__>::type
call_lognormal_rng(const T0__& mu,
                       const T1__& sigma, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 219;
        return stan::math::promote_scalar<fun_return_scalar_t__>(lognormal_rng(mu,sigma, base_rng__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_lognormal_rng_functor__ {
    template <typename T0__, typename T1__, class RNG>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& mu,
                       const T1__& sigma, RNG& base_rng__, std::ostream* pstream__) const {
        return call_lognormal_rng(mu, sigma, base_rng__, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
call_chi_square_lpdf(const T0__& y,
                         const T1__& nu, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 222;
        return stan::math::promote_scalar<fun_return_scalar_t__>(chi_square_log(y,nu));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
call_chi_square_lpdf(const T0__& y,
                         const T1__& nu, std::ostream* pstream__) {
    return call_chi_square_lpdf<false>(y,nu, pstream__);
}


struct call_chi_square_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& y,
                         const T1__& nu, std::ostream* pstream__) const {
        return call_chi_square_lpdf(y, nu, pstream__);
    }
};

template <typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
call_chi_square_cdf(const T0__& y,
                        const T1__& nu, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 225;
        return stan::math::promote_scalar<fun_return_scalar_t__>(chi_square_cdf(y,nu));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_chi_square_cdf_functor__ {
    template <typename T0__, typename T1__>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& y,
                        const T1__& nu, std::ostream* pstream__) const {
        return call_chi_square_cdf(y, nu, pstream__);
    }
};

template <typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
call_chi_square_lcdf(const T0__& y,
                         const T1__& nu, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 228;
        return stan::math::promote_scalar<fun_return_scalar_t__>(chi_square_cdf_log(y,nu));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_chi_square_lcdf_functor__ {
    template <typename T0__, typename T1__>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& y,
                         const T1__& nu, std::ostream* pstream__) const {
        return call_chi_square_lcdf(y, nu, pstream__);
    }
};

template <typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
call_chi_square_lccdf(const T0__& y,
                          const T1__& nu, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 231;
        return stan::math::promote_scalar<fun_return_scalar_t__>(chi_square_ccdf_log(y,nu));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_chi_square_lccdf_functor__ {
    template <typename T0__, typename T1__>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& y,
                          const T1__& nu, std::ostream* pstream__) const {
        return call_chi_square_lccdf(y, nu, pstream__);
    }
};

template <typename T0__, class RNG>
typename boost::math::tools::promote_args<T0__>::type
call_chi_square_rng(const T0__& nu, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 234;
        return stan::math::promote_scalar<fun_return_scalar_t__>(chi_square_rng(nu, base_rng__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_chi_square_rng_functor__ {
    template <typename T0__, class RNG>
        typename boost::math::tools::promote_args<T0__>::type
    operator()(const T0__& nu, RNG& base_rng__, std::ostream* pstream__) const {
        return call_chi_square_rng(nu, base_rng__, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
call_inv_chi_square_lpdf(const T0__& y,
                             const T1__& nu, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 237;
        return stan::math::promote_scalar<fun_return_scalar_t__>(inv_chi_square_log(y,nu));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
call_inv_chi_square_lpdf(const T0__& y,
                             const T1__& nu, std::ostream* pstream__) {
    return call_inv_chi_square_lpdf<false>(y,nu, pstream__);
}


struct call_inv_chi_square_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& y,
                             const T1__& nu, std::ostream* pstream__) const {
        return call_inv_chi_square_lpdf(y, nu, pstream__);
    }
};

template <typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
call_inv_chi_square_cdf(const T0__& y,
                            const T1__& nu, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 240;
        return stan::math::promote_scalar<fun_return_scalar_t__>(inv_chi_square_cdf(y,nu));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_inv_chi_square_cdf_functor__ {
    template <typename T0__, typename T1__>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& y,
                            const T1__& nu, std::ostream* pstream__) const {
        return call_inv_chi_square_cdf(y, nu, pstream__);
    }
};

template <typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
call_inv_chi_square_lcdf(const T0__& y,
                             const T1__& nu, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 243;
        return stan::math::promote_scalar<fun_return_scalar_t__>(inv_chi_square_cdf_log(y,nu));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_inv_chi_square_lcdf_functor__ {
    template <typename T0__, typename T1__>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& y,
                             const T1__& nu, std::ostream* pstream__) const {
        return call_inv_chi_square_lcdf(y, nu, pstream__);
    }
};

template <typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
call_inv_chi_square_lccdf(const T0__& y,
                              const T1__& nu, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 246;
        return stan::math::promote_scalar<fun_return_scalar_t__>(inv_chi_square_ccdf_log(y,nu));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_inv_chi_square_lccdf_functor__ {
    template <typename T0__, typename T1__>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& y,
                              const T1__& nu, std::ostream* pstream__) const {
        return call_inv_chi_square_lccdf(y, nu, pstream__);
    }
};

template <typename T0__, class RNG>
typename boost::math::tools::promote_args<T0__>::type
call_inv_chi_square_rng(const T0__& nu, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 249;
        return stan::math::promote_scalar<fun_return_scalar_t__>(inv_chi_square_rng(nu, base_rng__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_inv_chi_square_rng_functor__ {
    template <typename T0__, class RNG>
        typename boost::math::tools::promote_args<T0__>::type
    operator()(const T0__& nu, RNG& base_rng__, std::ostream* pstream__) const {
        return call_inv_chi_square_rng(nu, base_rng__, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_scaled_inv_chi_square_lpdf(const T0__& y,
                                    const T1__& nu,
                                    const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 252;
        return stan::math::promote_scalar<fun_return_scalar_t__>(scaled_inv_chi_square_log(y,nu,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_scaled_inv_chi_square_lpdf(const T0__& y,
                                    const T1__& nu,
                                    const T2__& sigma, std::ostream* pstream__) {
    return call_scaled_inv_chi_square_lpdf<false>(y,nu,sigma, pstream__);
}


struct call_scaled_inv_chi_square_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                                    const T1__& nu,
                                    const T2__& sigma, std::ostream* pstream__) const {
        return call_scaled_inv_chi_square_lpdf(y, nu, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_scaled_inv_chi_square_cdf(const T0__& y,
                                   const T1__& nu,
                                   const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 255;
        return stan::math::promote_scalar<fun_return_scalar_t__>(scaled_inv_chi_square_cdf(y,nu,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_scaled_inv_chi_square_cdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                                   const T1__& nu,
                                   const T2__& sigma, std::ostream* pstream__) const {
        return call_scaled_inv_chi_square_cdf(y, nu, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_scaled_inv_chi_square_lcdf(const T0__& y,
                                    const T1__& nu,
                                    const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 258;
        return stan::math::promote_scalar<fun_return_scalar_t__>(scaled_inv_chi_square_cdf_log(y,nu,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_scaled_inv_chi_square_lcdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                                    const T1__& nu,
                                    const T2__& sigma, std::ostream* pstream__) const {
        return call_scaled_inv_chi_square_lcdf(y, nu, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_scaled_inv_chi_square_lccdf(const T0__& y,
                                     const T1__& nu,
                                     const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 261;
        return stan::math::promote_scalar<fun_return_scalar_t__>(scaled_inv_chi_square_ccdf_log(y,nu,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_scaled_inv_chi_square_lccdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                                     const T1__& nu,
                                     const T2__& sigma, std::ostream* pstream__) const {
        return call_scaled_inv_chi_square_lccdf(y, nu, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, class RNG>
typename boost::math::tools::promote_args<T0__, T1__>::type
call_scaled_inv_chi_square_rng(const T0__& nu,
                                   const T1__& sigma, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 264;
        return stan::math::promote_scalar<fun_return_scalar_t__>(scaled_inv_chi_square_rng(nu,sigma, base_rng__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_scaled_inv_chi_square_rng_functor__ {
    template <typename T0__, typename T1__, class RNG>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& nu,
                                   const T1__& sigma, RNG& base_rng__, std::ostream* pstream__) const {
        return call_scaled_inv_chi_square_rng(nu, sigma, base_rng__, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
call_exponential_lpdf(const T0__& y,
                          const T1__& beta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 267;
        return stan::math::promote_scalar<fun_return_scalar_t__>(exponential_log(y,beta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
call_exponential_lpdf(const T0__& y,
                          const T1__& beta, std::ostream* pstream__) {
    return call_exponential_lpdf<false>(y,beta, pstream__);
}


struct call_exponential_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& y,
                          const T1__& beta, std::ostream* pstream__) const {
        return call_exponential_lpdf(y, beta, pstream__);
    }
};

template <typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
call_exponential_cdf(const T0__& y,
                         const T1__& beta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 270;
        return stan::math::promote_scalar<fun_return_scalar_t__>(exponential_cdf(y,beta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_exponential_cdf_functor__ {
    template <typename T0__, typename T1__>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& y,
                         const T1__& beta, std::ostream* pstream__) const {
        return call_exponential_cdf(y, beta, pstream__);
    }
};

template <typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
call_exponential_lcdf(const T0__& y,
                          const T1__& beta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 273;
        return stan::math::promote_scalar<fun_return_scalar_t__>(exponential_cdf_log(y,beta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_exponential_lcdf_functor__ {
    template <typename T0__, typename T1__>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& y,
                          const T1__& beta, std::ostream* pstream__) const {
        return call_exponential_lcdf(y, beta, pstream__);
    }
};

template <typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
call_exponential_lccdf(const T0__& y,
                           const T1__& beta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 276;
        return stan::math::promote_scalar<fun_return_scalar_t__>(exponential_ccdf_log(y,beta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_exponential_lccdf_functor__ {
    template <typename T0__, typename T1__>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& y,
                           const T1__& beta, std::ostream* pstream__) const {
        return call_exponential_lccdf(y, beta, pstream__);
    }
};

template <typename T0__, class RNG>
typename boost::math::tools::promote_args<T0__>::type
call_exponential_rng(const T0__& beta, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 279;
        return stan::math::promote_scalar<fun_return_scalar_t__>(exponential_rng(beta, base_rng__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_exponential_rng_functor__ {
    template <typename T0__, class RNG>
        typename boost::math::tools::promote_args<T0__>::type
    operator()(const T0__& beta, RNG& base_rng__, std::ostream* pstream__) const {
        return call_exponential_rng(beta, base_rng__, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_gamma_lpdf(const T0__& y,
                    const T1__& alpha,
                    const T2__& beta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 282;
        return stan::math::promote_scalar<fun_return_scalar_t__>(gamma_log(y,alpha,beta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_gamma_lpdf(const T0__& y,
                    const T1__& alpha,
                    const T2__& beta, std::ostream* pstream__) {
    return call_gamma_lpdf<false>(y,alpha,beta, pstream__);
}


struct call_gamma_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                    const T1__& alpha,
                    const T2__& beta, std::ostream* pstream__) const {
        return call_gamma_lpdf(y, alpha, beta, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_gamma_cdf(const T0__& y,
                   const T1__& alpha,
                   const T2__& beta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 285;
        return stan::math::promote_scalar<fun_return_scalar_t__>(gamma_cdf(y,alpha,beta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_gamma_cdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                   const T1__& alpha,
                   const T2__& beta, std::ostream* pstream__) const {
        return call_gamma_cdf(y, alpha, beta, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_gamma_lcdf(const T0__& y,
                    const T1__& alpha,
                    const T2__& beta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 288;
        return stan::math::promote_scalar<fun_return_scalar_t__>(gamma_cdf_log(y,alpha,beta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_gamma_lcdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                    const T1__& alpha,
                    const T2__& beta, std::ostream* pstream__) const {
        return call_gamma_lcdf(y, alpha, beta, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_gamma_lccdf(const T0__& y,
                     const T1__& alpha,
                     const T2__& beta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 291;
        return stan::math::promote_scalar<fun_return_scalar_t__>(gamma_ccdf_log(y,alpha,beta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_gamma_lccdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                     const T1__& alpha,
                     const T2__& beta, std::ostream* pstream__) const {
        return call_gamma_lccdf(y, alpha, beta, pstream__);
    }
};

template <typename T0__, typename T1__, class RNG>
typename boost::math::tools::promote_args<T0__, T1__>::type
call_gamma_rng(const T0__& alpha,
                   const T1__& beta, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 294;
        return stan::math::promote_scalar<fun_return_scalar_t__>(gamma_rng(alpha,beta, base_rng__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_gamma_rng_functor__ {
    template <typename T0__, typename T1__, class RNG>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& alpha,
                   const T1__& beta, RNG& base_rng__, std::ostream* pstream__) const {
        return call_gamma_rng(alpha, beta, base_rng__, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_inv_gamma_lpdf(const T0__& y,
                        const T1__& alpha,
                        const T2__& beta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 297;
        return stan::math::promote_scalar<fun_return_scalar_t__>(inv_gamma_log(y,alpha,beta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_inv_gamma_lpdf(const T0__& y,
                        const T1__& alpha,
                        const T2__& beta, std::ostream* pstream__) {
    return call_inv_gamma_lpdf<false>(y,alpha,beta, pstream__);
}


struct call_inv_gamma_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                        const T1__& alpha,
                        const T2__& beta, std::ostream* pstream__) const {
        return call_inv_gamma_lpdf(y, alpha, beta, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_inv_gamma_cdf(const T0__& y,
                       const T1__& alpha,
                       const T2__& beta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 300;
        return stan::math::promote_scalar<fun_return_scalar_t__>(inv_gamma_cdf(y,alpha,beta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_inv_gamma_cdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                       const T1__& alpha,
                       const T2__& beta, std::ostream* pstream__) const {
        return call_inv_gamma_cdf(y, alpha, beta, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_inv_gamma_lcdf(const T0__& y,
                        const T1__& alpha,
                        const T2__& beta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 303;
        return stan::math::promote_scalar<fun_return_scalar_t__>(inv_gamma_cdf_log(y,alpha,beta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_inv_gamma_lcdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                        const T1__& alpha,
                        const T2__& beta, std::ostream* pstream__) const {
        return call_inv_gamma_lcdf(y, alpha, beta, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_inv_gamma_lccdf(const T0__& y,
                         const T1__& alpha,
                         const T2__& beta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 306;
        return stan::math::promote_scalar<fun_return_scalar_t__>(inv_gamma_ccdf_log(y,alpha,beta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_inv_gamma_lccdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                         const T1__& alpha,
                         const T2__& beta, std::ostream* pstream__) const {
        return call_inv_gamma_lccdf(y, alpha, beta, pstream__);
    }
};

template <typename T0__, typename T1__, class RNG>
typename boost::math::tools::promote_args<T0__, T1__>::type
call_inv_gamma_rng(const T0__& alpha,
                       const T1__& beta, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 309;
        return stan::math::promote_scalar<fun_return_scalar_t__>(inv_gamma_rng(alpha,beta, base_rng__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_inv_gamma_rng_functor__ {
    template <typename T0__, typename T1__, class RNG>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& alpha,
                       const T1__& beta, RNG& base_rng__, std::ostream* pstream__) const {
        return call_inv_gamma_rng(alpha, beta, base_rng__, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_weibull_lpdf(const T0__& y,
                      const T1__& alpha,
                      const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 312;
        return stan::math::promote_scalar<fun_return_scalar_t__>(weibull_log(y,alpha,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_weibull_lpdf(const T0__& y,
                      const T1__& alpha,
                      const T2__& sigma, std::ostream* pstream__) {
    return call_weibull_lpdf<false>(y,alpha,sigma, pstream__);
}


struct call_weibull_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                      const T1__& alpha,
                      const T2__& sigma, std::ostream* pstream__) const {
        return call_weibull_lpdf(y, alpha, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_weibull_cdf(const T0__& y,
                     const T1__& alpha,
                     const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 315;
        return stan::math::promote_scalar<fun_return_scalar_t__>(weibull_cdf(y,alpha,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_weibull_cdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                     const T1__& alpha,
                     const T2__& sigma, std::ostream* pstream__) const {
        return call_weibull_cdf(y, alpha, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_weibull_lcdf(const T0__& y,
                      const T1__& alpha,
                      const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 318;
        return stan::math::promote_scalar<fun_return_scalar_t__>(weibull_cdf_log(y,alpha,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_weibull_lcdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                      const T1__& alpha,
                      const T2__& sigma, std::ostream* pstream__) const {
        return call_weibull_lcdf(y, alpha, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_weibull_lccdf(const T0__& y,
                       const T1__& alpha,
                       const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 321;
        return stan::math::promote_scalar<fun_return_scalar_t__>(weibull_ccdf_log(y,alpha,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_weibull_lccdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                       const T1__& alpha,
                       const T2__& sigma, std::ostream* pstream__) const {
        return call_weibull_lccdf(y, alpha, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, class RNG>
typename boost::math::tools::promote_args<T0__, T1__>::type
call_weibull_rng(const T0__& alpha,
                     const T1__& sigma, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 324;
        return stan::math::promote_scalar<fun_return_scalar_t__>(weibull_rng(alpha,sigma, base_rng__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_weibull_rng_functor__ {
    template <typename T0__, typename T1__, class RNG>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& alpha,
                     const T1__& sigma, RNG& base_rng__, std::ostream* pstream__) const {
        return call_weibull_rng(alpha, sigma, base_rng__, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_frechet_lpdf(const T0__& y,
                      const T1__& alpha,
                      const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 327;
        return stan::math::promote_scalar<fun_return_scalar_t__>(frechet_log(y,alpha,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_frechet_lpdf(const T0__& y,
                      const T1__& alpha,
                      const T2__& sigma, std::ostream* pstream__) {
    return call_frechet_lpdf<false>(y,alpha,sigma, pstream__);
}


struct call_frechet_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                      const T1__& alpha,
                      const T2__& sigma, std::ostream* pstream__) const {
        return call_frechet_lpdf(y, alpha, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_frechet_cdf(const T0__& y,
                     const T1__& alpha,
                     const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 330;
        return stan::math::promote_scalar<fun_return_scalar_t__>(frechet_cdf(y,alpha,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_frechet_cdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                     const T1__& alpha,
                     const T2__& sigma, std::ostream* pstream__) const {
        return call_frechet_cdf(y, alpha, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_frechet_lcdf(const T0__& y,
                      const T1__& alpha,
                      const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 333;
        return stan::math::promote_scalar<fun_return_scalar_t__>(frechet_cdf_log(y,alpha,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_frechet_lcdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                      const T1__& alpha,
                      const T2__& sigma, std::ostream* pstream__) const {
        return call_frechet_lcdf(y, alpha, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_frechet_lccdf(const T0__& y,
                       const T1__& alpha,
                       const T2__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 336;
        return stan::math::promote_scalar<fun_return_scalar_t__>(frechet_ccdf_log(y,alpha,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_frechet_lccdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                       const T1__& alpha,
                       const T2__& sigma, std::ostream* pstream__) const {
        return call_frechet_lccdf(y, alpha, sigma, pstream__);
    }
};

template <typename T0__, typename T1__, class RNG>
typename boost::math::tools::promote_args<T0__, T1__>::type
call_frechet_rng(const T0__& alpha,
                     const T1__& sigma, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 339;
        return stan::math::promote_scalar<fun_return_scalar_t__>(frechet_rng(alpha,sigma, base_rng__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_frechet_rng_functor__ {
    template <typename T0__, typename T1__, class RNG>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& alpha,
                     const T1__& sigma, RNG& base_rng__, std::ostream* pstream__) const {
        return call_frechet_rng(alpha, sigma, base_rng__, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
call_rayleigh_lpdf(const T0__& y,
                       const T1__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 342;
        return stan::math::promote_scalar<fun_return_scalar_t__>(rayleigh_log(y,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
call_rayleigh_lpdf(const T0__& y,
                       const T1__& sigma, std::ostream* pstream__) {
    return call_rayleigh_lpdf<false>(y,sigma, pstream__);
}


struct call_rayleigh_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& y,
                       const T1__& sigma, std::ostream* pstream__) const {
        return call_rayleigh_lpdf(y, sigma, pstream__);
    }
};

template <typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
call_rayleigh_cdf(const T0__& y,
                      const T1__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 345;
        return stan::math::promote_scalar<fun_return_scalar_t__>(rayleigh_cdf(y,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_rayleigh_cdf_functor__ {
    template <typename T0__, typename T1__>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& y,
                      const T1__& sigma, std::ostream* pstream__) const {
        return call_rayleigh_cdf(y, sigma, pstream__);
    }
};

template <typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
call_rayleigh_lcdf(const T0__& y,
                       const T1__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 348;
        return stan::math::promote_scalar<fun_return_scalar_t__>(rayleigh_cdf_log(y,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_rayleigh_lcdf_functor__ {
    template <typename T0__, typename T1__>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& y,
                       const T1__& sigma, std::ostream* pstream__) const {
        return call_rayleigh_lcdf(y, sigma, pstream__);
    }
};

template <typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
call_rayleigh_lccdf(const T0__& y,
                        const T1__& sigma, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 351;
        return stan::math::promote_scalar<fun_return_scalar_t__>(rayleigh_ccdf_log(y,sigma));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_rayleigh_lccdf_functor__ {
    template <typename T0__, typename T1__>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& y,
                        const T1__& sigma, std::ostream* pstream__) const {
        return call_rayleigh_lccdf(y, sigma, pstream__);
    }
};

template <typename T0__, class RNG>
typename boost::math::tools::promote_args<T0__>::type
call_rayleigh_rng(const T0__& sigma, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 354;
        return stan::math::promote_scalar<fun_return_scalar_t__>(rayleigh_rng(sigma, base_rng__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_rayleigh_rng_functor__ {
    template <typename T0__, class RNG>
        typename boost::math::tools::promote_args<T0__>::type
    operator()(const T0__& sigma, RNG& base_rng__, std::ostream* pstream__) const {
        return call_rayleigh_rng(sigma, base_rng__, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
call_wiener_lpdf(const T0__& y,
                     const T1__& alpha,
                     const T2__& tau,
                     const T3__& beta,
                     const T4__& delta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 357;
        return stan::math::promote_scalar<fun_return_scalar_t__>(wiener_log(y,alpha,tau,beta,delta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
call_wiener_lpdf(const T0__& y,
                     const T1__& alpha,
                     const T2__& tau,
                     const T3__& beta,
                     const T4__& delta, std::ostream* pstream__) {
    return call_wiener_lpdf<false>(y,alpha,tau,beta,delta, pstream__);
}


struct call_wiener_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
    operator()(const T0__& y,
                     const T1__& alpha,
                     const T2__& tau,
                     const T3__& beta,
                     const T4__& delta, std::ostream* pstream__) const {
        return call_wiener_lpdf(y, alpha, tau, beta, delta, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_pareto_lpdf(const T0__& y,
                     const T1__& y_min,
                     const T2__& alpha, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 360;
        return stan::math::promote_scalar<fun_return_scalar_t__>(pareto_log(y,y_min,alpha));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_pareto_lpdf(const T0__& y,
                     const T1__& y_min,
                     const T2__& alpha, std::ostream* pstream__) {
    return call_pareto_lpdf<false>(y,y_min,alpha, pstream__);
}


struct call_pareto_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                     const T1__& y_min,
                     const T2__& alpha, std::ostream* pstream__) const {
        return call_pareto_lpdf(y, y_min, alpha, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_pareto_cdf(const T0__& y,
                    const T1__& y_min,
                    const T2__& alpha, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 363;
        return stan::math::promote_scalar<fun_return_scalar_t__>(pareto_cdf(y,y_min,alpha));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_pareto_cdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                    const T1__& y_min,
                    const T2__& alpha, std::ostream* pstream__) const {
        return call_pareto_cdf(y, y_min, alpha, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_pareto_lcdf(const T0__& y,
                     const T1__& y_min,
                     const T2__& alpha, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 366;
        return stan::math::promote_scalar<fun_return_scalar_t__>(pareto_cdf_log(y,y_min,alpha));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_pareto_lcdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                     const T1__& y_min,
                     const T2__& alpha, std::ostream* pstream__) const {
        return call_pareto_lcdf(y, y_min, alpha, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_pareto_lccdf(const T0__& y,
                      const T1__& y_min,
                      const T2__& alpha, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 369;
        return stan::math::promote_scalar<fun_return_scalar_t__>(pareto_ccdf_log(y,y_min,alpha));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_pareto_lccdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                      const T1__& y_min,
                      const T2__& alpha, std::ostream* pstream__) const {
        return call_pareto_lccdf(y, y_min, alpha, pstream__);
    }
};

template <typename T0__, typename T1__, class RNG>
typename boost::math::tools::promote_args<T0__, T1__>::type
call_pareto_rng(const T0__& y_min,
                    const T1__& alpha, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 372;
        return stan::math::promote_scalar<fun_return_scalar_t__>(pareto_rng(y_min,alpha, base_rng__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_pareto_rng_functor__ {
    template <typename T0__, typename T1__, class RNG>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& y_min,
                    const T1__& alpha, RNG& base_rng__, std::ostream* pstream__) const {
        return call_pareto_rng(y_min, alpha, base_rng__, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
call_pareto_type_2_lpdf(const T0__& y,
                            const T1__& mu,
                            const T2__& lambda,
                            const T3__& alpha, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 375;
        return stan::math::promote_scalar<fun_return_scalar_t__>(pareto_type_2_log(y,mu,lambda,alpha));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
call_pareto_type_2_lpdf(const T0__& y,
                            const T1__& mu,
                            const T2__& lambda,
                            const T3__& alpha, std::ostream* pstream__) {
    return call_pareto_type_2_lpdf<false>(y,mu,lambda,alpha, pstream__);
}


struct call_pareto_type_2_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
    operator()(const T0__& y,
                            const T1__& mu,
                            const T2__& lambda,
                            const T3__& alpha, std::ostream* pstream__) const {
        return call_pareto_type_2_lpdf(y, mu, lambda, alpha, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
call_pareto_type_2_cdf(const T0__& y,
                           const T1__& mu,
                           const T2__& lambda,
                           const T3__& alpha, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 378;
        return stan::math::promote_scalar<fun_return_scalar_t__>(pareto_type_2_cdf(y,mu,lambda,alpha));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_pareto_type_2_cdf_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
    operator()(const T0__& y,
                           const T1__& mu,
                           const T2__& lambda,
                           const T3__& alpha, std::ostream* pstream__) const {
        return call_pareto_type_2_cdf(y, mu, lambda, alpha, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
call_pareto_type_2_lcdf(const T0__& y,
                            const T1__& mu,
                            const T2__& lambda,
                            const T3__& alpha, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 381;
        return stan::math::promote_scalar<fun_return_scalar_t__>(pareto_type_2_cdf_log(y,mu,lambda,alpha));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_pareto_type_2_lcdf_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
    operator()(const T0__& y,
                            const T1__& mu,
                            const T2__& lambda,
                            const T3__& alpha, std::ostream* pstream__) const {
        return call_pareto_type_2_lcdf(y, mu, lambda, alpha, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
call_pareto_type_2_lccdf(const T0__& y,
                             const T1__& mu,
                             const T2__& lambda,
                             const T3__& alpha, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 384;
        return stan::math::promote_scalar<fun_return_scalar_t__>(pareto_type_2_ccdf_log(y,mu,lambda,alpha));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_pareto_type_2_lccdf_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
    operator()(const T0__& y,
                             const T1__& mu,
                             const T2__& lambda,
                             const T3__& alpha, std::ostream* pstream__) const {
        return call_pareto_type_2_lccdf(y, mu, lambda, alpha, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, class RNG>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_pareto_type_2_rng(const T0__& mu,
                           const T1__& lambda,
                           const T2__& alpha, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 387;
        return stan::math::promote_scalar<fun_return_scalar_t__>(pareto_type_2_rng(mu,lambda,alpha, base_rng__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_pareto_type_2_rng_functor__ {
    template <typename T0__, typename T1__, typename T2__, class RNG>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& mu,
                           const T1__& lambda,
                           const T2__& alpha, RNG& base_rng__, std::ostream* pstream__) const {
        return call_pareto_type_2_rng(mu, lambda, alpha, base_rng__, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_beta_lpdf(const T0__& y,
                   const T1__& alpha,
                   const T2__& beta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 390;
        return stan::math::promote_scalar<fun_return_scalar_t__>(beta_log(y,alpha,beta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_beta_lpdf(const T0__& y,
                   const T1__& alpha,
                   const T2__& beta, std::ostream* pstream__) {
    return call_beta_lpdf<false>(y,alpha,beta, pstream__);
}


struct call_beta_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                   const T1__& alpha,
                   const T2__& beta, std::ostream* pstream__) const {
        return call_beta_lpdf(y, alpha, beta, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_beta_cdf(const T0__& y,
                  const T1__& alpha,
                  const T2__& beta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 393;
        return stan::math::promote_scalar<fun_return_scalar_t__>(beta_cdf(y,alpha,beta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_beta_cdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                  const T1__& alpha,
                  const T2__& beta, std::ostream* pstream__) const {
        return call_beta_cdf(y, alpha, beta, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_beta_lcdf(const T0__& y,
                   const T1__& alpha,
                   const T2__& beta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 396;
        return stan::math::promote_scalar<fun_return_scalar_t__>(beta_cdf_log(y,alpha,beta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_beta_lcdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                   const T1__& alpha,
                   const T2__& beta, std::ostream* pstream__) const {
        return call_beta_lcdf(y, alpha, beta, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_beta_lccdf(const T0__& y,
                    const T1__& alpha,
                    const T2__& beta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 399;
        return stan::math::promote_scalar<fun_return_scalar_t__>(beta_ccdf_log(y,alpha,beta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_beta_lccdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                    const T1__& alpha,
                    const T2__& beta, std::ostream* pstream__) const {
        return call_beta_lccdf(y, alpha, beta, pstream__);
    }
};

template <typename T0__, typename T1__, class RNG>
typename boost::math::tools::promote_args<T0__, T1__>::type
call_beta_rng(const T0__& alpha,
                  const T1__& beta, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 402;
        return stan::math::promote_scalar<fun_return_scalar_t__>(beta_rng(alpha,beta, base_rng__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_beta_rng_functor__ {
    template <typename T0__, typename T1__, class RNG>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& alpha,
                  const T1__& beta, RNG& base_rng__, std::ostream* pstream__) const {
        return call_beta_rng(alpha, beta, base_rng__, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_von_mises_lpdf(const T0__& y,
                        const T1__& mu,
                        const T2__& kappa, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 405;
        return stan::math::promote_scalar<fun_return_scalar_t__>(von_mises_log(y,mu,kappa));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_von_mises_lpdf(const T0__& y,
                        const T1__& mu,
                        const T2__& kappa, std::ostream* pstream__) {
    return call_von_mises_lpdf<false>(y,mu,kappa, pstream__);
}


struct call_von_mises_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                        const T1__& mu,
                        const T2__& kappa, std::ostream* pstream__) const {
        return call_von_mises_lpdf(y, mu, kappa, pstream__);
    }
};

template <typename T0__, typename T1__, class RNG>
typename boost::math::tools::promote_args<T0__, T1__>::type
call_von_mises_rng(const T0__& mu,
                       const T1__& kappa, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 408;
        return stan::math::promote_scalar<fun_return_scalar_t__>(von_mises_rng(mu,kappa, base_rng__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_von_mises_rng_functor__ {
    template <typename T0__, typename T1__, class RNG>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& mu,
                       const T1__& kappa, RNG& base_rng__, std::ostream* pstream__) const {
        return call_von_mises_rng(mu, kappa, base_rng__, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_uniform_lpdf(const T0__& y,
                      const T1__& alpha,
                      const T2__& beta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 411;
        return stan::math::promote_scalar<fun_return_scalar_t__>(uniform_log(y,alpha,beta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_uniform_lpdf(const T0__& y,
                      const T1__& alpha,
                      const T2__& beta, std::ostream* pstream__) {
    return call_uniform_lpdf<false>(y,alpha,beta, pstream__);
}


struct call_uniform_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                      const T1__& alpha,
                      const T2__& beta, std::ostream* pstream__) const {
        return call_uniform_lpdf(y, alpha, beta, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_uniform_cdf(const T0__& y,
                     const T1__& alpha,
                     const T2__& beta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 414;
        return stan::math::promote_scalar<fun_return_scalar_t__>(uniform_cdf(y,alpha,beta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_uniform_cdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                     const T1__& alpha,
                     const T2__& beta, std::ostream* pstream__) const {
        return call_uniform_cdf(y, alpha, beta, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_uniform_lcdf(const T0__& y,
                      const T1__& alpha,
                      const T2__& beta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 417;
        return stan::math::promote_scalar<fun_return_scalar_t__>(uniform_cdf_log(y,alpha,beta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_uniform_lcdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                      const T1__& alpha,
                      const T2__& beta, std::ostream* pstream__) const {
        return call_uniform_lcdf(y, alpha, beta, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
call_uniform_lccdf(const T0__& y,
                       const T1__& alpha,
                       const T2__& beta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 420;
        return stan::math::promote_scalar<fun_return_scalar_t__>(uniform_ccdf_log(y,alpha,beta));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_uniform_lccdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y,
                       const T1__& alpha,
                       const T2__& beta, std::ostream* pstream__) const {
        return call_uniform_lccdf(y, alpha, beta, pstream__);
    }
};

template <typename T0__, typename T1__, class RNG>
typename boost::math::tools::promote_args<T0__, T1__>::type
call_uniform_rng(const T0__& alpha,
                     const T1__& beta, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 423;
        return stan::math::promote_scalar<fun_return_scalar_t__>(uniform_rng(alpha,beta, base_rng__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct call_uniform_rng_functor__ {
    template <typename T0__, typename T1__, class RNG>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& alpha,
                     const T1__& beta, RNG& base_rng__, std::ostream* pstream__) const {
        return call_uniform_rng(alpha, beta, base_rng__, pstream__);
    }
};

// [[Rcpp::export]]
double
call_normal_lpdf(const double& y,
                     const double& mu,
                     const double& sigma, std::ostream* pstream__ = 0){
  return call_normal_lpdf<false, double, double, double>(y, mu, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_normal_cdf(const double& y,
                    const double& mu,
                    const double& sigma, std::ostream* pstream__ = 0){
  return call_normal_cdf<double, double, double>(y, mu, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_normal_lcdf(const double& y,
                     const double& mu,
                     const double& sigma, std::ostream* pstream__ = 0){
  return call_normal_lcdf<double, double, double>(y, mu, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_normal_lccdf(const double& y,
                      const double& mu,
                      const double& sigma, std::ostream* pstream__ = 0){
  return call_normal_lccdf<double, double, double>(y, mu, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_normal_rng(const double& mu,
                    const double& sigma, boost::ecuyer1988& base_rng__, std::ostream* pstream__ = 0){
  return call_normal_rng<double, double, boost::ecuyer1988>(mu, sigma, base_rng__, pstream__);
}

// [[Rcpp::export]]
double
call_exp_mod_normal_lpdf(const double& y,
                             const double& mu,
                             const double& sigma,
                             const double& lambda, std::ostream* pstream__ = 0){
  return call_exp_mod_normal_lpdf<false, double, double, double, double>(y, mu, sigma, lambda, pstream__);
}

// [[Rcpp::export]]
double
call_exp_mod_normal_cdf(const double& y,
                            const double& mu,
                            const double& sigma,
                            const double& lambda, std::ostream* pstream__ = 0){
  return call_exp_mod_normal_cdf<double, double, double, double>(y, mu, sigma, lambda, pstream__);
}

// [[Rcpp::export]]
double
call_exp_mod_normal_lcdf(const double& y,
                             const double& mu,
                             const double& sigma,
                             const double& lambda, std::ostream* pstream__ = 0){
  return call_exp_mod_normal_lcdf<double, double, double, double>(y, mu, sigma, lambda, pstream__);
}

// [[Rcpp::export]]
double
call_exp_mod_normal_lccdf(const double& y,
                              const double& mu,
                              const double& sigma,
                              const double& lambda, std::ostream* pstream__ = 0){
  return call_exp_mod_normal_lccdf<double, double, double, double>(y, mu, sigma, lambda, pstream__);
}

// [[Rcpp::export]]
double
call_exp_mod_normal_rng(const double& mu,
                            const double& sigma,
                            const double& lambda, boost::ecuyer1988& base_rng__, std::ostream* pstream__ = 0){
  return call_exp_mod_normal_rng<double, double, double, boost::ecuyer1988>(mu, sigma, lambda, base_rng__, pstream__);
}

// [[Rcpp::export]]
double
call_skew_normal_lpdf(const double& y,
                          const double& xi,
                          const double& omega,
                          const double& alpha, std::ostream* pstream__ = 0){
  return call_skew_normal_lpdf<false, double, double, double, double>(y, xi, omega, alpha, pstream__);
}

// [[Rcpp::export]]
double
call_skew_normal_cdf(const double& y,
                         const double& xi,
                         const double& omega,
                         const double& alpha, std::ostream* pstream__ = 0){
  return call_skew_normal_cdf<double, double, double, double>(y, xi, omega, alpha, pstream__);
}

// [[Rcpp::export]]
double
call_skew_normal_lcdf(const double& y,
                          const double& xi,
                          const double& omega,
                          const double& alpha, std::ostream* pstream__ = 0){
  return call_skew_normal_lcdf<double, double, double, double>(y, xi, omega, alpha, pstream__);
}

// [[Rcpp::export]]
double
call_skew_normal_lccdf(const double& y,
                           const double& xi,
                           const double& omega,
                           const double& alpha, std::ostream* pstream__ = 0){
  return call_skew_normal_lccdf<double, double, double, double>(y, xi, omega, alpha, pstream__);
}

// [[Rcpp::export]]
double
call_skew_normal_rng(const double& xi,
                         const double& omega,
                         const double& alpha, boost::ecuyer1988& base_rng__, std::ostream* pstream__ = 0){
  return call_skew_normal_rng<double, double, double, boost::ecuyer1988>(xi, omega, alpha, base_rng__, pstream__);
}

// [[Rcpp::export]]
double
call_student_t_lpdf(const double& y,
                        const double& nu,
                        const double& mu,
                        const double& sigma, std::ostream* pstream__ = 0){
  return call_student_t_lpdf<false, double, double, double, double>(y, nu, mu, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_student_t_cdf(const double& y,
                       const double& nu,
                       const double& mu,
                       const double& sigma, std::ostream* pstream__ = 0){
  return call_student_t_cdf<double, double, double, double>(y, nu, mu, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_student_t_lcdf(const double& y,
                        const double& nu,
                        const double& mu,
                        const double& sigma, std::ostream* pstream__ = 0){
  return call_student_t_lcdf<double, double, double, double>(y, nu, mu, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_student_t_lccdf(const double& y,
                         const double& nu,
                         const double& mu,
                         const double& sigma, std::ostream* pstream__ = 0){
  return call_student_t_lccdf<double, double, double, double>(y, nu, mu, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_student_t_rng(const double& nu,
                       const double& mu,
                       const double& sigma, boost::ecuyer1988& base_rng__, std::ostream* pstream__ = 0){
  return call_student_t_rng<double, double, double, boost::ecuyer1988>(nu, mu, sigma, base_rng__, pstream__);
}

// [[Rcpp::export]]
double
call_cauchy_lpdf(const double& y,
                     const double& mu,
                     const double& sigma, std::ostream* pstream__ = 0){
  return call_cauchy_lpdf<false, double, double, double>(y, mu, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_cauchy_cdf(const double& y,
                    const double& mu,
                    const double& sigma, std::ostream* pstream__ = 0){
  return call_cauchy_cdf<double, double, double>(y, mu, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_cauchy_lcdf(const double& y,
                     const double& mu,
                     const double& sigma, std::ostream* pstream__ = 0){
  return call_cauchy_lcdf<double, double, double>(y, mu, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_cauchy_lccdf(const double& y,
                      const double& mu,
                      const double& sigma, std::ostream* pstream__ = 0){
  return call_cauchy_lccdf<double, double, double>(y, mu, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_cauchy_rng(const double& mu,
                    const double& sigma, boost::ecuyer1988& base_rng__, std::ostream* pstream__ = 0){
  return call_cauchy_rng<double, double, boost::ecuyer1988>(mu, sigma, base_rng__, pstream__);
}

// [[Rcpp::export]]
double
call_double_exponential_lpdf(const double& y,
                                 const double& mu,
                                 const double& sigma, std::ostream* pstream__ = 0){
  return call_double_exponential_lpdf<false, double, double, double>(y, mu, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_double_exponential_cdf(const double& y,
                                const double& mu,
                                const double& sigma, std::ostream* pstream__ = 0){
  return call_double_exponential_cdf<double, double, double>(y, mu, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_double_exponential_lcdf(const double& y,
                                 const double& mu,
                                 const double& sigma, std::ostream* pstream__ = 0){
  return call_double_exponential_lcdf<double, double, double>(y, mu, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_double_exponential_lccdf(const double& y,
                                  const double& mu,
                                  const double& sigma, std::ostream* pstream__ = 0){
  return call_double_exponential_lccdf<double, double, double>(y, mu, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_double_exponential_rng(const double& mu,
                                const double& sigma, boost::ecuyer1988& base_rng__, std::ostream* pstream__ = 0){
  return call_double_exponential_rng<double, double, boost::ecuyer1988>(mu, sigma, base_rng__, pstream__);
}

// [[Rcpp::export]]
double
call_logistic_lpdf(const double& y,
                       const double& mu,
                       const double& sigma, std::ostream* pstream__ = 0){
  return call_logistic_lpdf<false, double, double, double>(y, mu, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_logistic_cdf(const double& y,
                      const double& mu,
                      const double& sigma, std::ostream* pstream__ = 0){
  return call_logistic_cdf<double, double, double>(y, mu, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_logistic_lcdf(const double& y,
                       const double& mu,
                       const double& sigma, std::ostream* pstream__ = 0){
  return call_logistic_lcdf<double, double, double>(y, mu, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_logistic_lccdf(const double& y,
                        const double& mu,
                        const double& sigma, std::ostream* pstream__ = 0){
  return call_logistic_lccdf<double, double, double>(y, mu, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_logistic_rng(const double& mu,
                      const double& sigma, boost::ecuyer1988& base_rng__, std::ostream* pstream__ = 0){
  return call_logistic_rng<double, double, boost::ecuyer1988>(mu, sigma, base_rng__, pstream__);
}

// [[Rcpp::export]]
double
call_gumbel_lpdf(const double& y,
                     const double& mu,
                     const double& beta, std::ostream* pstream__ = 0){
  return call_gumbel_lpdf<false, double, double, double>(y, mu, beta, pstream__);
}

// [[Rcpp::export]]
double
call_gumbel_cdf(const double& y,
                    const double& mu,
                    const double& beta, std::ostream* pstream__ = 0){
  return call_gumbel_cdf<double, double, double>(y, mu, beta, pstream__);
}

// [[Rcpp::export]]
double
call_gumbel_lcdf(const double& y,
                     const double& mu,
                     const double& beta, std::ostream* pstream__ = 0){
  return call_gumbel_lcdf<double, double, double>(y, mu, beta, pstream__);
}

// [[Rcpp::export]]
double
call_gumbel_lccdf(const double& y,
                      const double& mu,
                      const double& beta, std::ostream* pstream__ = 0){
  return call_gumbel_lccdf<double, double, double>(y, mu, beta, pstream__);
}

// [[Rcpp::export]]
double
call_gumbel_rng(const double& mu,
                    const double& beta, boost::ecuyer1988& base_rng__, std::ostream* pstream__ = 0){
  return call_gumbel_rng<double, double, boost::ecuyer1988>(mu, beta, base_rng__, pstream__);
}

// [[Rcpp::export]]
double
call_lognormal_lpdf(const double& y,
                        const double& mu,
                        const double& sigma, std::ostream* pstream__ = 0){
  return call_lognormal_lpdf<false, double, double, double>(y, mu, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_lognormal_cdf(const double& y,
                       const double& mu,
                       const double& sigma, std::ostream* pstream__ = 0){
  return call_lognormal_cdf<double, double, double>(y, mu, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_lognormal_lcdf(const double& y,
                        const double& mu,
                        const double& sigma, std::ostream* pstream__ = 0){
  return call_lognormal_lcdf<double, double, double>(y, mu, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_lognormal_lccdf(const double& y,
                         const double& mu,
                         const double& sigma, std::ostream* pstream__ = 0){
  return call_lognormal_lccdf<double, double, double>(y, mu, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_lognormal_rng(const double& mu,
                       const double& sigma, boost::ecuyer1988& base_rng__, std::ostream* pstream__ = 0){
  return call_lognormal_rng<double, double, boost::ecuyer1988>(mu, sigma, base_rng__, pstream__);
}

// [[Rcpp::export]]
double
call_chi_square_lpdf(const double& y,
                         const double& nu, std::ostream* pstream__ = 0){
  return call_chi_square_lpdf<false, double, double>(y, nu, pstream__);
}

// [[Rcpp::export]]
double
call_chi_square_cdf(const double& y,
                        const double& nu, std::ostream* pstream__ = 0){
  return call_chi_square_cdf<double, double>(y, nu, pstream__);
}

// [[Rcpp::export]]
double
call_chi_square_lcdf(const double& y,
                         const double& nu, std::ostream* pstream__ = 0){
  return call_chi_square_lcdf<double, double>(y, nu, pstream__);
}

// [[Rcpp::export]]
double
call_chi_square_lccdf(const double& y,
                          const double& nu, std::ostream* pstream__ = 0){
  return call_chi_square_lccdf<double, double>(y, nu, pstream__);
}

// [[Rcpp::export]]
double
call_chi_square_rng(const double& nu, boost::ecuyer1988& base_rng__, std::ostream* pstream__ = 0){
  return call_chi_square_rng<double, boost::ecuyer1988>(nu, base_rng__, pstream__);
}

// [[Rcpp::export]]
double
call_inv_chi_square_lpdf(const double& y,
                             const double& nu, std::ostream* pstream__ = 0){
  return call_inv_chi_square_lpdf<false, double, double>(y, nu, pstream__);
}

// [[Rcpp::export]]
double
call_inv_chi_square_cdf(const double& y,
                            const double& nu, std::ostream* pstream__ = 0){
  return call_inv_chi_square_cdf<double, double>(y, nu, pstream__);
}

// [[Rcpp::export]]
double
call_inv_chi_square_lcdf(const double& y,
                             const double& nu, std::ostream* pstream__ = 0){
  return call_inv_chi_square_lcdf<double, double>(y, nu, pstream__);
}

// [[Rcpp::export]]
double
call_inv_chi_square_lccdf(const double& y,
                              const double& nu, std::ostream* pstream__ = 0){
  return call_inv_chi_square_lccdf<double, double>(y, nu, pstream__);
}

// [[Rcpp::export]]
double
call_inv_chi_square_rng(const double& nu, boost::ecuyer1988& base_rng__, std::ostream* pstream__ = 0){
  return call_inv_chi_square_rng<double, boost::ecuyer1988>(nu, base_rng__, pstream__);
}

// [[Rcpp::export]]
double
call_scaled_inv_chi_square_lpdf(const double& y,
                                    const double& nu,
                                    const double& sigma, std::ostream* pstream__ = 0){
  return call_scaled_inv_chi_square_lpdf<false, double, double, double>(y, nu, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_scaled_inv_chi_square_cdf(const double& y,
                                   const double& nu,
                                   const double& sigma, std::ostream* pstream__ = 0){
  return call_scaled_inv_chi_square_cdf<double, double, double>(y, nu, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_scaled_inv_chi_square_lcdf(const double& y,
                                    const double& nu,
                                    const double& sigma, std::ostream* pstream__ = 0){
  return call_scaled_inv_chi_square_lcdf<double, double, double>(y, nu, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_scaled_inv_chi_square_lccdf(const double& y,
                                     const double& nu,
                                     const double& sigma, std::ostream* pstream__ = 0){
  return call_scaled_inv_chi_square_lccdf<double, double, double>(y, nu, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_scaled_inv_chi_square_rng(const double& nu,
                                   const double& sigma, boost::ecuyer1988& base_rng__, std::ostream* pstream__ = 0){
  return call_scaled_inv_chi_square_rng<double, double, boost::ecuyer1988>(nu, sigma, base_rng__, pstream__);
}

// [[Rcpp::export]]
double
call_exponential_lpdf(const double& y,
                          const double& beta, std::ostream* pstream__ = 0){
  return call_exponential_lpdf<false, double, double>(y, beta, pstream__);
}

// [[Rcpp::export]]
double
call_exponential_cdf(const double& y,
                         const double& beta, std::ostream* pstream__ = 0){
  return call_exponential_cdf<double, double>(y, beta, pstream__);
}

// [[Rcpp::export]]
double
call_exponential_lcdf(const double& y,
                          const double& beta, std::ostream* pstream__ = 0){
  return call_exponential_lcdf<double, double>(y, beta, pstream__);
}

// [[Rcpp::export]]
double
call_exponential_lccdf(const double& y,
                           const double& beta, std::ostream* pstream__ = 0){
  return call_exponential_lccdf<double, double>(y, beta, pstream__);
}

// [[Rcpp::export]]
double
call_exponential_rng(const double& beta, boost::ecuyer1988& base_rng__, std::ostream* pstream__ = 0){
  return call_exponential_rng<double, boost::ecuyer1988>(beta, base_rng__, pstream__);
}

// [[Rcpp::export]]
double
call_gamma_lpdf(const double& y,
                    const double& alpha,
                    const double& beta, std::ostream* pstream__ = 0){
  return call_gamma_lpdf<false, double, double, double>(y, alpha, beta, pstream__);
}

// [[Rcpp::export]]
double
call_gamma_cdf(const double& y,
                   const double& alpha,
                   const double& beta, std::ostream* pstream__ = 0){
  return call_gamma_cdf<double, double, double>(y, alpha, beta, pstream__);
}

// [[Rcpp::export]]
double
call_gamma_lcdf(const double& y,
                    const double& alpha,
                    const double& beta, std::ostream* pstream__ = 0){
  return call_gamma_lcdf<double, double, double>(y, alpha, beta, pstream__);
}

// [[Rcpp::export]]
double
call_gamma_lccdf(const double& y,
                     const double& alpha,
                     const double& beta, std::ostream* pstream__ = 0){
  return call_gamma_lccdf<double, double, double>(y, alpha, beta, pstream__);
}

// [[Rcpp::export]]
double
call_gamma_rng(const double& alpha,
                   const double& beta, boost::ecuyer1988& base_rng__, std::ostream* pstream__ = 0){
  return call_gamma_rng<double, double, boost::ecuyer1988>(alpha, beta, base_rng__, pstream__);
}

// [[Rcpp::export]]
double
call_inv_gamma_lpdf(const double& y,
                        const double& alpha,
                        const double& beta, std::ostream* pstream__ = 0){
  return call_inv_gamma_lpdf<false, double, double, double>(y, alpha, beta, pstream__);
}

// [[Rcpp::export]]
double
call_inv_gamma_cdf(const double& y,
                       const double& alpha,
                       const double& beta, std::ostream* pstream__ = 0){
  return call_inv_gamma_cdf<double, double, double>(y, alpha, beta, pstream__);
}

// [[Rcpp::export]]
double
call_inv_gamma_lcdf(const double& y,
                        const double& alpha,
                        const double& beta, std::ostream* pstream__ = 0){
  return call_inv_gamma_lcdf<double, double, double>(y, alpha, beta, pstream__);
}

// [[Rcpp::export]]
double
call_inv_gamma_lccdf(const double& y,
                         const double& alpha,
                         const double& beta, std::ostream* pstream__ = 0){
  return call_inv_gamma_lccdf<double, double, double>(y, alpha, beta, pstream__);
}

// [[Rcpp::export]]
double
call_inv_gamma_rng(const double& alpha,
                       const double& beta, boost::ecuyer1988& base_rng__, std::ostream* pstream__ = 0){
  return call_inv_gamma_rng<double, double, boost::ecuyer1988>(alpha, beta, base_rng__, pstream__);
}

// [[Rcpp::export]]
double
call_weibull_lpdf(const double& y,
                      const double& alpha,
                      const double& sigma, std::ostream* pstream__ = 0){
  return call_weibull_lpdf<false, double, double, double>(y, alpha, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_weibull_cdf(const double& y,
                     const double& alpha,
                     const double& sigma, std::ostream* pstream__ = 0){
  return call_weibull_cdf<double, double, double>(y, alpha, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_weibull_lcdf(const double& y,
                      const double& alpha,
                      const double& sigma, std::ostream* pstream__ = 0){
  return call_weibull_lcdf<double, double, double>(y, alpha, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_weibull_lccdf(const double& y,
                       const double& alpha,
                       const double& sigma, std::ostream* pstream__ = 0){
  return call_weibull_lccdf<double, double, double>(y, alpha, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_weibull_rng(const double& alpha,
                     const double& sigma, boost::ecuyer1988& base_rng__, std::ostream* pstream__ = 0){
  return call_weibull_rng<double, double, boost::ecuyer1988>(alpha, sigma, base_rng__, pstream__);
}

// [[Rcpp::export]]
double
call_frechet_lpdf(const double& y,
                      const double& alpha,
                      const double& sigma, std::ostream* pstream__ = 0){
  return call_frechet_lpdf<false, double, double, double>(y, alpha, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_frechet_cdf(const double& y,
                     const double& alpha,
                     const double& sigma, std::ostream* pstream__ = 0){
  return call_frechet_cdf<double, double, double>(y, alpha, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_frechet_lcdf(const double& y,
                      const double& alpha,
                      const double& sigma, std::ostream* pstream__ = 0){
  return call_frechet_lcdf<double, double, double>(y, alpha, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_frechet_lccdf(const double& y,
                       const double& alpha,
                       const double& sigma, std::ostream* pstream__ = 0){
  return call_frechet_lccdf<double, double, double>(y, alpha, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_frechet_rng(const double& alpha,
                     const double& sigma, boost::ecuyer1988& base_rng__, std::ostream* pstream__ = 0){
  return call_frechet_rng<double, double, boost::ecuyer1988>(alpha, sigma, base_rng__, pstream__);
}

// [[Rcpp::export]]
double
call_rayleigh_lpdf(const double& y,
                       const double& sigma, std::ostream* pstream__ = 0){
  return call_rayleigh_lpdf<false, double, double>(y, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_rayleigh_cdf(const double& y,
                      const double& sigma, std::ostream* pstream__ = 0){
  return call_rayleigh_cdf<double, double>(y, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_rayleigh_lcdf(const double& y,
                       const double& sigma, std::ostream* pstream__ = 0){
  return call_rayleigh_lcdf<double, double>(y, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_rayleigh_lccdf(const double& y,
                        const double& sigma, std::ostream* pstream__ = 0){
  return call_rayleigh_lccdf<double, double>(y, sigma, pstream__);
}

// [[Rcpp::export]]
double
call_rayleigh_rng(const double& sigma, boost::ecuyer1988& base_rng__, std::ostream* pstream__ = 0){
  return call_rayleigh_rng<double, boost::ecuyer1988>(sigma, base_rng__, pstream__);
}

// [[Rcpp::export]]
double
call_wiener_lpdf(const double& y,
                     const double& alpha,
                     const double& tau,
                     const double& beta,
                     const double& delta, std::ostream* pstream__ = 0){
  return call_wiener_lpdf<false, double, double, double, double, double>(y, alpha, tau, beta, delta, pstream__);
}

// [[Rcpp::export]]
double
call_pareto_lpdf(const double& y,
                     const double& y_min,
                     const double& alpha, std::ostream* pstream__ = 0){
  return call_pareto_lpdf<false, double, double, double>(y, y_min, alpha, pstream__);
}

// [[Rcpp::export]]
double
call_pareto_cdf(const double& y,
                    const double& y_min,
                    const double& alpha, std::ostream* pstream__ = 0){
  return call_pareto_cdf<double, double, double>(y, y_min, alpha, pstream__);
}

// [[Rcpp::export]]
double
call_pareto_lcdf(const double& y,
                     const double& y_min,
                     const double& alpha, std::ostream* pstream__ = 0){
  return call_pareto_lcdf<double, double, double>(y, y_min, alpha, pstream__);
}

// [[Rcpp::export]]
double
call_pareto_lccdf(const double& y,
                      const double& y_min,
                      const double& alpha, std::ostream* pstream__ = 0){
  return call_pareto_lccdf<double, double, double>(y, y_min, alpha, pstream__);
}

// [[Rcpp::export]]
double
call_pareto_rng(const double& y_min,
                    const double& alpha, boost::ecuyer1988& base_rng__, std::ostream* pstream__ = 0){
  return call_pareto_rng<double, double, boost::ecuyer1988>(y_min, alpha, base_rng__, pstream__);
}

// [[Rcpp::export]]
double
call_pareto_type_2_lpdf(const double& y,
                            const double& mu,
                            const double& lambda,
                            const double& alpha, std::ostream* pstream__ = 0){
  return call_pareto_type_2_lpdf<false, double, double, double, double>(y, mu, lambda, alpha, pstream__);
}

// [[Rcpp::export]]
double
call_pareto_type_2_cdf(const double& y,
                           const double& mu,
                           const double& lambda,
                           const double& alpha, std::ostream* pstream__ = 0){
  return call_pareto_type_2_cdf<double, double, double, double>(y, mu, lambda, alpha, pstream__);
}

// [[Rcpp::export]]
double
call_pareto_type_2_lcdf(const double& y,
                            const double& mu,
                            const double& lambda,
                            const double& alpha, std::ostream* pstream__ = 0){
  return call_pareto_type_2_lcdf<double, double, double, double>(y, mu, lambda, alpha, pstream__);
}

// [[Rcpp::export]]
double
call_pareto_type_2_lccdf(const double& y,
                             const double& mu,
                             const double& lambda,
                             const double& alpha, std::ostream* pstream__ = 0){
  return call_pareto_type_2_lccdf<double, double, double, double>(y, mu, lambda, alpha, pstream__);
}

// [[Rcpp::export]]
double
call_pareto_type_2_rng(const double& mu,
                           const double& lambda,
                           const double& alpha, boost::ecuyer1988& base_rng__, std::ostream* pstream__ = 0){
  return call_pareto_type_2_rng<double, double, double, boost::ecuyer1988>(mu, lambda, alpha, base_rng__, pstream__);
}

// [[Rcpp::export]]
double
call_beta_lpdf(const double& y,
                   const double& alpha,
                   const double& beta, std::ostream* pstream__ = 0){
  return call_beta_lpdf<false, double, double, double>(y, alpha, beta, pstream__);
}

// [[Rcpp::export]]
double
call_beta_cdf(const double& y,
                  const double& alpha,
                  const double& beta, std::ostream* pstream__ = 0){
  return call_beta_cdf<double, double, double>(y, alpha, beta, pstream__);
}

// [[Rcpp::export]]
double
call_beta_lcdf(const double& y,
                   const double& alpha,
                   const double& beta, std::ostream* pstream__ = 0){
  return call_beta_lcdf<double, double, double>(y, alpha, beta, pstream__);
}

// [[Rcpp::export]]
double
call_beta_lccdf(const double& y,
                    const double& alpha,
                    const double& beta, std::ostream* pstream__ = 0){
  return call_beta_lccdf<double, double, double>(y, alpha, beta, pstream__);
}

// [[Rcpp::export]]
double
call_beta_rng(const double& alpha,
                  const double& beta, boost::ecuyer1988& base_rng__, std::ostream* pstream__ = 0){
  return call_beta_rng<double, double, boost::ecuyer1988>(alpha, beta, base_rng__, pstream__);
}

// [[Rcpp::export]]
double
call_von_mises_lpdf(const double& y,
                        const double& mu,
                        const double& kappa, std::ostream* pstream__ = 0){
  return call_von_mises_lpdf<false, double, double, double>(y, mu, kappa, pstream__);
}

// [[Rcpp::export]]
double
call_von_mises_rng(const double& mu,
                       const double& kappa, boost::ecuyer1988& base_rng__, std::ostream* pstream__ = 0){
  return call_von_mises_rng<double, double, boost::ecuyer1988>(mu, kappa, base_rng__, pstream__);
}

// [[Rcpp::export]]
double
call_uniform_lpdf(const double& y,
                      const double& alpha,
                      const double& beta, std::ostream* pstream__ = 0){
  return call_uniform_lpdf<false, double, double, double>(y, alpha, beta, pstream__);
}

// [[Rcpp::export]]
double
call_uniform_cdf(const double& y,
                     const double& alpha,
                     const double& beta, std::ostream* pstream__ = 0){
  return call_uniform_cdf<double, double, double>(y, alpha, beta, pstream__);
}

// [[Rcpp::export]]
double
call_uniform_lcdf(const double& y,
                      const double& alpha,
                      const double& beta, std::ostream* pstream__ = 0){
  return call_uniform_lcdf<double, double, double>(y, alpha, beta, pstream__);
}

// [[Rcpp::export]]
double
call_uniform_lccdf(const double& y,
                       const double& alpha,
                       const double& beta, std::ostream* pstream__ = 0){
  return call_uniform_lccdf<double, double, double>(y, alpha, beta, pstream__);
}

// [[Rcpp::export]]
double
call_uniform_rng(const double& alpha,
                     const double& beta, boost::ecuyer1988& base_rng__, std::ostream* pstream__ = 0){
  return call_uniform_rng<double, double, boost::ecuyer1988>(alpha, beta, base_rng__, pstream__);
}

 } 
